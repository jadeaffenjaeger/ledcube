#include "cube.h"
#include "stm32f1xx.h"
#include "string.h"


static uint8_t cube[SIZE][SIZE][SIZE];
static uint8_t bit_buffer[SIZE][SIZE+1];

static uint8_t current_layer            = 0;

// Quadratic LUT that maps 8bit value to 4 bit color space
static uint8_t lut16_8[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05,     
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
    0x07, 0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
    0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
    0x0d, 0x0d, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f
};


void cube_init(void) {
    /* Write layer byte for each layer in buffer*/
    for(uint32_t i = 0; i < SIZE; i++) {
        bit_buffer[i][SIZE] = 1 << i;
    }

    for (uint32_t y = 0; y < SIZE; y++) {
        for (uint32_t z = 0; z < SIZE; z++) {
            cube[y][z][4] = 255;
        }
    }
}

/* Loads the bit buffer with bit states for the nth bit for each layer*/
void cube_fillBitBuffer(uint8_t bitPosition) {
    for(uint32_t z = 0; z < SIZE; z++) {
        for(uint32_t x = 0; x < SIZE; x++) {
            uint8_t temp = 0;
            for(uint32_t y = 0; y < SIZE; y++) {
                if((cube[x][y][z] & (1 << bitPosition)) != 0) {
                    temp |= 1 << y;
                }
            }
            bit_buffer[z][x] = temp;

        }
    }
}

/* Returns pointer to the next bit stream that needs to be clocked out.*/
uint8_t* cube_getNext(void) {
    return bit_buffer[current_layer];
}

void cube_linearExtrapolate(uint8_t point, uint8_t value, SExtrapolation_t* buffer) {

    uint8_t a = (point - (point % 16));
    uint32_t x0_v = ((15 - a) * value)/16;
    uint32_t x1_v = (a * value)/16;

    buffer->p1    = (uint8_t) x0_v;
    buffer->p2    = (uint8_t) x1_v;
}

void cube_drawPoint(uint8_t x, uint8_t y, uint8_t z, uint8_t value) {
    if(x > 127 || y > 127 || z > 127){
        return;
    }

    SExtrapolation_t xAx, yAx0, yAx1, zAx0, zAx1, zAx2, zAx3;
    uint8_t x0, x1, y0, y1, z0, z1;
    cube_linearExtrapolate(x, value, &xAx);

    cube_linearExtrapolate(y, xAx.p1, &yAx0);
    cube_linearExtrapolate(y, xAx.p2, &yAx1);

    cube_linearExtrapolate(z, yAx0.p1, &zAx0);
    cube_linearExtrapolate(z, yAx0.p2, &zAx1);
    cube_linearExtrapolate(z, yAx1.p1, &zAx2);
    cube_linearExtrapolate(z, yAx1.p2, &zAx3);

    x0 = x / 16;
    x1 = x0 + 1;
    y0 = y / 16;
    y1 = y0 + 1;
    z0 = z / 16;
    z1 = z0 + 1;

    cube_setPx(x0, y0, z0, zAx0.p1);
    cube_setPx(x0, y0, z1, zAx0.p2);
    cube_setPx(x0, y1, z0, zAx1.p1);
    cube_setPx(x0, y1, z1, zAx1.p2);
    cube_setPx(x1, y0, z0, zAx2.p1);
    cube_setPx(x1, y0, z1, zAx2.p2);
    cube_setPx(x1, y1, z0, zAx3.p1);
    cube_setPx(x1, y1, z1, zAx3.p2);
}


void cube_fill(uint8_t val) {
    val = lut16_8[val];
    memset(cube, val, SIZE*SIZE*SIZE);
}

void cube_setPx(uint8_t x, uint8_t y, uint8_t z, uint8_t value) {
    if(x >= SIZE || y >= SIZE || z >= SIZE){
        return;
    }

    value = lut16_8[value];
    cube[x][y][z] = value;
}

void cube_update(void) {
    static uint8_t current_bitPosition      = 0;
    static uint16_t current_bitCounter      = 0;
    current_layer += 1;
    if (current_layer == SIZE) {
        current_layer = 0;
        current_bitCounter += 1;
        if(current_bitCounter == 1 << (current_bitPosition)) {
            current_bitCounter = 0;
            current_bitPosition += 1;
            if (current_bitPosition == RESOLUTION) {
                current_bitPosition = 0;
            }
            cube_fillBitBuffer(current_bitPosition);
        }
    }
}

