#include "cube.h"

/*
 *This file implements all cube low-level access functions as well the BAM handling routines that are called from SPI/timer intterrupt
 */

static uint8_t cube[SIZE][SIZE][SIZE];
static uint8_t bit_buffer[SIZE][SIZE+1];

static uint8_t current_layer            = 0;

// Quadratic LUT that maps 8bit value to 4 bit color space
static uint8_t lut16_8[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05,     
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
    0x07, 0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
    0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
    0x0d, 0x0d, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f
};


// Reset cube contents
void cube_init(void) {
    /* Write layer byte for each layer in buffer*/
    for(uint32_t i = 0; i < SIZE; i++) {
        bit_buffer[i][SIZE] = 1 << i;
    }

    for (uint32_t y = 0; y < SIZE; y++) {
        for (uint32_t z = 0; z < SIZE; z++) {
            cube[y][z][4] = 255;
        }
    }
}

/* Loads the bit buffer with bit states for the nth bit for each layer*/
void cube_fillBitBuffer(uint8_t bitPosition) {
    for(uint32_t z = 0; z < SIZE; z++) {
        for(uint32_t x = 0; x < SIZE; x++) {
            uint8_t temp = 0;
            for(uint32_t y = 0; y < SIZE; y++) {
                if((cube[x][y][z] & (1 << bitPosition)) != 0) {
                    temp |= 1 << y;
                }
            }
            bit_buffer[z][x] = temp;

        }
    }
}

/* Returns pointer to the next bit stream that needs to be clocked out.*/
uint8_t* cube_getNext(void) {
    return bit_buffer[current_layer];
}

// Update Cube BAM FSM
void cube_update(void) {
    static uint8_t current_bitPosition      = 0;
    static uint16_t current_bitCounter      = 0;
    current_layer += 1;
    if (current_layer == SIZE) {
        current_layer = 0;
        current_bitCounter += 1;
        if(current_bitCounter == 1 << (current_bitPosition)) {
            current_bitCounter = 0;
            current_bitPosition += 1;
            if (current_bitPosition == RESOLUTION) {
                current_bitPosition = 0;
            }
            cube_fillBitBuffer(current_bitPosition);
        }
    }
}

// Fill cube with constant value
void cube_fill(uint8_t val) {
    val = lut16_8[val];
    memset(cube, val, SIZE*SIZE*SIZE);
}

// Set single pixel in cube to specified brightness
void cube_setPx(uint8_t x, uint8_t y, uint8_t z, uint8_t value) {
    if(x >= SIZE || y >= SIZE || z >= SIZE){
        return;
    }

    value = lut16_8[value];
    cube[x][y][z] = value;
}

void cube_shiftLeft() {
    for(uint32_t xx = 0; xx < SIZE; xx++) {
        for(uint32_t yy = 0; yy < SIZE; yy++) {
            for(uint32_t zz = 0; zz < SIZE; zz++) {
                if(xx == SIZE -1) {
                    cube[xx][yy][zz] = 0;
                } else {
                    cube[xx][yy][zz] = cube[xx + 1][yy][zz];
                }
            }
        }
    }
}
